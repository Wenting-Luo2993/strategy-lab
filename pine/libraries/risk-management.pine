//@version=6

// @description Risk Management Library for ORB Strategy
// Handles position initialization, trailing stops, exits, and R-level calculations
library("orb_risk_lib", overlay=true)

// @type PositionData
// @field entry_price Entry price of the position
// @field initial_stop Initial stop loss price
// @field initial_risk Initial risk amount per share
// @field current_trailing_stop Current trailing stop price
// @field highest_r_achieved Highest R multiple reached
// @field position_is_long Whether position is long (true) or short (false)
export type PositionData
    float entry_price
    float initial_stop
    float initial_risk
    float current_trailing_stop
    float highest_r_achieved
    bool position_is_long

// Enhanced PositionSizeConfig to include all trading parameters
// @type PositionSizeConfig (Enhanced)
// @field account_capital Total account capital
// @field risk_percentage Risk percentage per trade (as decimal, e.g., 0.01 for 1%)
// @field max_position_percentage Maximum position value as percentage of capital (as decimal)
// @field min_risk_per_share Minimum risk per share threshold
// @field cash_buffer_percentage Cash buffer to maintain (as decimal)
// @field use_confidence_sizing Whether to use confidence-based position sizing
// @field enable_min_risk_filter Whether to enable minimum risk filtering
// @field label_distance Y Distance for entry labels (default 0.8 of low)
// @field initial_stop_buffer_percentage Percentage of OR range for stop placement (default 0.6 = 60%)
export type EnhancedPositionSizeConfig
    float account_capital
    float risk_percentage = 0.01
    float max_position_percentage = 0.80
    float min_risk_per_share = 0.0
    float cash_buffer_percentage = 0.10
    bool use_confidence_sizing = false
    bool enable_min_risk_filter = true
    float label_distance = 0.8
    float initial_stop_buffer_percentage = 0.6

// @type TradingState
// @field first_breakout_today Whether this is first breakout today
// @field in_position Whether already in position
// @field current_price Current price for entry
// @field or_high Opening Range high
// @field or_low Opening Range low
export type TradingState
    bool first_breakout_today
    bool in_position
    float current_price
    float or_high
    float or_low

// @type RiskLevels
// @field r2_level 2R profit target level
// @field r3_level 3R profit target level
// @field r4_level 4R profit target level
export type RiskLevels
    float r2_level
    float r3_level
    float r4_level

// @type PositionSizeConfig
// @field account_capital Total account capital
// @field risk_percentage Risk percentage per trade (as decimal, e.g., 0.01 for 1%)
// @field max_position_percentage Maximum position value as percentage of capital (as decimal)
// @field min_risk_per_share Minimum risk per share threshold
// @field cash_buffer_percentage Cash buffer to maintain (as decimal)
export type PositionSizeConfig
    float account_capital
    float risk_percentage = 0.01
    float max_position_percentage = 0.80
    float min_risk_per_share = 0.0
    float cash_buffer_percentage = 0.10

// @type PositionSizeResult
// @field shares Number of shares to buy/sell
// @field position_value Total position value (shares * entry_price)
// @field actual_risk Actual risk amount for this position
// @field actual_risk_percentage Actual risk as percentage of capital
// @field is_capital_constrained Whether position was limited by capital constraints
// @field is_risk_constrained Whether position was limited by minimum risk threshold
export type PositionSizeResult
    int shares
    float position_value
    float actual_risk
    float actual_risk_percentage
    bool is_capital_constrained
    bool is_risk_constrained

// @type TradeExecutionResult
// @field trade_executed Whether trade was executed
// @field shares Number of shares traded
// @field actual_risk Actual risk amount
// @field entry_price Entry price
// @field initial_stop Initial stop price
// @field is_cap_constrained Whether position was capital constrained
// @field is_risk_constrained Whether position was risk constrained
export type TradeExecutionResult
    bool trade_executed = false
    float shares = 0.0
    float actual_risk = 0.0
    float entry_price = na
    float initial_stop = na
    bool is_cap_constrained = false
    bool is_risk_constrained = false

// @function Initialize position data when entering a trade
// @param is_long Whether the position is long
// @param entry_price The entry price
// @param or_high Opening range high
// @param or_low Opening range low
// @param or_stop_level Percentage of OR range for stop placement
// @returns PositionData object with initialized values
export initialize_position(bool is_long, float entry_price, float or_high, float or_low, float or_stop_level) =>
    pos = PositionData.new()
    pos.entry_price := entry_price
    pos.position_is_long := is_long
    
    if is_long
        pos.initial_stop := or_low + (or_high - or_low) * or_stop_level
        pos.initial_risk := entry_price - pos.initial_stop
    else
        pos.initial_stop := or_high - (or_high - or_low) * or_stop_level
        pos.initial_risk := pos.initial_stop - entry_price
    
    pos.current_trailing_stop := pos.initial_stop
    pos.highest_r_achieved := 0.0
    pos

// @function Calculate initial stop price based on OR levels
// @param is_long True for long position
// @param or_high Opening Range high
// @param or_low Opening Range low
// @param stop_buffer_percentage Buffer percentage (default 0.6 = 60%)
// @returns Initial stop price
export calculate_initial_stop_price(bool is_long, float or_high, float or_low, float stop_buffer_percentage = 0.6) =>
    if is_long
        or_low + (or_high - or_low) * (stop_buffer_percentage / 100.0)
    else
        or_high - (or_high - or_low)* (stop_buffer_percentage / 100.0)


// @function Create enhanced position sizing configuration
// @param account_capital Total account capital
// @param risk_percentage Risk percentage per trade (as decimal)
// @param max_position_percentage Maximum position percentage (as decimal)
// @param use_confidence_sizing Whether to use confidence-based sizing
// @param min_risk_per_share Minimum risk per share
// @param enable_min_risk_filter Whether to enable minimum risk filter
// @returns EnhancedPositionSizeConfig object
export create_enhanced_position_config(float account_capital, float risk_percentage, float max_position_percentage, bool use_confidence_sizing, float min_risk_per_share, bool enable_min_risk_filter) =>
    config = EnhancedPositionSizeConfig.new()
    config.account_capital := account_capital
    config.risk_percentage := risk_percentage
    config.max_position_percentage := max_position_percentage
    config.use_confidence_sizing := use_confidence_sizing
    config.min_risk_per_share := min_risk_per_share
    config.enable_min_risk_filter := enable_min_risk_filter
    config.cash_buffer_percentage := 0.10
    config

// @function Create trading state object
// @param first_breakout_today Whether this is first breakout today
// @param in_position Whether already in position
// @param current_price Current price for entry
// @param or_high Opening Range high
// @param or_low Opening Range low
// @returns TradingState object
export create_trading_state(bool first_breakout_today, bool in_position, float current_price, float or_high, float or_low) =>
    state = TradingState.new()
    state.first_breakout_today := first_breakout_today
    state.in_position := in_position
    state.current_price := current_price
    state.or_high := or_high
    state.or_low := or_low
    state


// @type Configuration for trailing stop behavior
// @field levels Array of R levels where trailing stop adjustments occur
// @field stops Array of corresponding trailing stop R values
// @field step_size Minimum step size for stop adjustments (in R)
// @field start_level R level where trailing begins
// @field trail_behind How much to trail behind highest R (for dynamic trailing)
// @field use_dynamic_trail Whether to use dynamic trailing (true) or fixed levels (false)
export type TrailingStopConfig
    array<float> levels
    array<float> stops  
    float step_size = 0.5
    float start_level = 2.0
    float trail_behind = 0.5
    bool use_dynamic_trail = false

// @function Create a standard trailing stop configuration (like your original)
// @returns TrailingStopConfig
export create_standard_config() =>
    levels = array.from(2.0, 3.0, 3.5)
    stops = array.from(1.5, 2.5, 0.0)  // 0.0 means dynamic trailing
    TrailingStopConfig.new(levels, stops, 0.5, 2.0, 0.5, false)

// @function Create a custom step-based trailing stop configuration
// @param start_r R level to start trailing
// @param step_r Step size in R multiples
// @param trail_r How much to trail behind
// @returns TrailingStopConfig
export create_step_config(float start_r = 2.0, float step_r = 0.5, float trail_r = 0.5) =>
    TrailingStopConfig.new(array.new<float>(), array.new<float>(), step_r, start_r, trail_r, true)

// @function Create configuration from your table example with dynamic trailing above 5R
// @returns TrailingStopConfig for the table system with dynamic extension
export create_table_config_with_dynamic() =>
    levels = array.from(2.0, 3.0, 4.0, 4.5, 5.0)
    stops = array.from(1.0, 2.0, 3.5, 4.0, 0.0)  // 0.0 triggers dynamic trailing above 5R
    TrailingStopConfig.new(levels, stops, 0.5, 2.0, 0.5, false)

// @function Update trailing stop based on current price and configurable parameters
// @param pos_data Current position data
// @param current_price Current market price
// @param config Trailing stop configuration
// @returns Updated PositionData with new trailing stop
export update_trailing_stop(PositionData pos_data, float current_price, TrailingStopConfig config) =>
    if na(pos_data.entry_price) or na(pos_data.initial_risk) or pos_data.initial_risk <= 0
        pos_data
    else
        // Calculate current R multiple
        current_r = pos_data.position_is_long ? 
             (current_price - pos_data.entry_price) / pos_data.initial_risk : 
             (pos_data.entry_price - current_price) / pos_data.initial_risk
        
        // Update highest R achieved
        if current_r > pos_data.highest_r_achieved
            pos_data.highest_r_achieved := current_r
        
        // Only proceed if we've reached the start level
        if pos_data.highest_r_achieved >= config.start_level

            
            target_trailing_r = 0.0
            
            if config.use_dynamic_trail
                // Dynamic trailing - trail behind by fixed amount with step size
                stepped_r = math.floor(pos_data.highest_r_achieved / config.step_size) * config.step_size
                target_trailing_r := math.max(0.0, stepped_r - config.trail_behind)
            else
                // Level-based trailing using configuration arrays
                if array.size(config.levels) > 0 and array.size(config.stops) > 0
                    // Find the appropriate trailing stop level
                    for i = array.size(config.levels) - 1 to 0
                        level = array.get(config.levels, i)
                        if pos_data.highest_r_achieved >= level
                            stop_value = array.get(config.stops, i)
                            if stop_value == 0.0  // Dynamic trailing indicator
                                target_trailing_r := math.max(0.0, pos_data.highest_r_achieved - config.trail_behind)
                            else
                                target_trailing_r := stop_value
                            break
            
            // Apply step size constraint if specified
            if config.step_size > 0
                target_trailing_r := math.floor(target_trailing_r / config.step_size) * config.step_size
            
            // Calculate the actual stop price based on target R
            new_trailing_stop = pos_data.position_is_long ? 
                 pos_data.entry_price + (target_trailing_r * pos_data.initial_risk) :
                 pos_data.entry_price - (target_trailing_r * pos_data.initial_risk)
            
            // Only move stop in favorable direction
            if (pos_data.position_is_long and new_trailing_stop > pos_data.current_trailing_stop) or
               (not pos_data.position_is_long and new_trailing_stop < pos_data.current_trailing_stop)
                pos_data.current_trailing_stop := new_trailing_stop
        
        pos_data

// @function Simplified wrapper that uses standard configuration
// @param pos_data Current position data
// @param current_price Current market price
// @returns Updated PositionData with new trailing stop
export update_trailing_stop_standard(PositionData pos_data, float current_price) =>
    config = create_standard_config()
    update_trailing_stop(pos_data, current_price, config)

// @function Calculate position size using risk-based approach with capital constraints
// @param entry_price Entry price per share
// @param risk_per_share Risk per share (entry - stop for long, stop - entry for short)
// @param config PositionSizeConfig object with parameters
// @returns PositionSizeResult with calculated position details
export calculate_position_size_advanced(float entry_price, float risk_per_share, PositionSizeConfig config) =>
    result = PositionSizeResult.new()
    
    if na(entry_price) or na(risk_per_share) or entry_price <= 0 or risk_per_share <= 0 or config.account_capital <= 0
        // Invalid inputs
        result.shares := 0
        result.position_value := 0.0
        result.actual_risk := 0.0
        result.actual_risk_percentage := 0.0
        result.is_capital_constrained := false
        result.is_risk_constrained := false
        result
    else
        // Check minimum risk threshold
        if config.min_risk_per_share > 0 and risk_per_share < config.min_risk_per_share
            result.shares := 0
            result.position_value := 0.0
            result.actual_risk := 0.0
            result.actual_risk_percentage := 0.0
            result.is_capital_constrained := false
            result.is_risk_constrained := true
            result
        else
            // Calculate target risk amount
            target_risk_amount = config.account_capital * config.risk_percentage
            
            // Calculate risk-based shares
            risk_based_shares = math.floor(target_risk_amount / risk_per_share)
            
            // Calculate maximum allowed position value
            available_capital = config.account_capital * (1.0 - config.cash_buffer_percentage)
            max_position_value = available_capital * config.max_position_percentage
            
            // Calculate capital-constrained shares
            capital_constrained_shares = math.floor(max_position_value / entry_price)
            
            // Use the smaller of the two
            final_shares = math.min(risk_based_shares, capital_constrained_shares)
            
            // Calculate actual values
            result.shares := int(final_shares)
            result.position_value := final_shares * entry_price
            result.actual_risk := final_shares * risk_per_share
            result.actual_risk_percentage := result.actual_risk / config.account_capital
            result.is_capital_constrained := capital_constrained_shares < risk_based_shares
            result.is_risk_constrained := false
            
            result

// @function Calculate position size with fixed maximum position value
// @param entry_price Entry price per share
// @param risk_per_share Risk per share
// @param account_capital Total account capital
// @param risk_percentage Risk percentage per trade (as decimal)
// @param max_position_value Fixed maximum position value in dollars
// @returns PositionSizeResult
export calculate_position_size_fixed_max(float entry_price, float risk_per_share, float account_capital, float risk_percentage, float max_position_value) =>
    config = PositionSizeConfig.new()
    config.account_capital := account_capital
    config.risk_percentage := risk_percentage
    config.max_position_percentage := max_position_value / account_capital
    config.min_risk_per_share := 0.0
    config.cash_buffer_percentage := 0.0
    
    calculate_position_size_advanced(entry_price, risk_per_share, config)

// @function Calculate position size with percentage-based maximum
// @param entry_price Entry price per share
// @param risk_per_share Risk per share
// @param account_capital Total account capital
// @param risk_percentage Risk percentage per trade (as decimal)
// @param max_position_percentage Maximum position as percentage of capital (as decimal)
// @returns PositionSizeResult
export calculate_position_size_percentage_max(float entry_price, float risk_per_share, float account_capital, float risk_percentage, float max_position_percentage) =>
    config = PositionSizeConfig.new()
    config.account_capital := account_capital
    config.risk_percentage := risk_percentage
    config.max_position_percentage := max_position_percentage
    config.min_risk_per_share := 0.0
    config.cash_buffer_percentage := 0.0
    
    calculate_position_size_advanced(entry_price, risk_per_share, config)

// @function Calculate position size with minimum risk per share filter
// @param entry_price Entry price per share
// @param risk_per_share Risk per share
// @param account_capital Total account capital
// @param risk_percentage Risk percentage per trade (as decimal)
// @param min_risk_per_share Minimum risk per share threshold (trades below this are skipped)
// @returns PositionSizeResult
export calculate_position_size_min_risk(float entry_price, float risk_per_share, float account_capital, float risk_percentage, float min_risk_per_share) =>
    config = PositionSizeConfig.new()
    config.account_capital := account_capital
    config.risk_percentage := risk_percentage
    config.max_position_percentage := 0.90
    config.min_risk_per_share := min_risk_per_share
    config.cash_buffer_percentage := 0.10
    
    calculate_position_size_advanced(entry_price, risk_per_share, config)

// @function Simple position size calculation (basic risk-based)
// @param entry_price Entry price per share
// @param risk_per_share Risk per share
// @param account_capital Total account capital
// @param risk_percentage Risk percentage per trade (as decimal, e.g., 0.01 for 1%)
// @returns Number of shares (integer)
export calculate_position_size_simple(float entry_price, float risk_per_share, float account_capital, float risk_percentage) =>
    if na(entry_price) or na(risk_per_share) or entry_price <= 0 or risk_per_share <= 0 or account_capital <= 0
        0
    else
        target_risk = account_capital * risk_percentage
        shares = math.floor(target_risk / risk_per_share)
        int(shares)

// @function Calculate position size based on confidence score
// @param confidence_score Confidence score (1-4)
// @returns Position size percentage
export calculate_position_size_confidence(int confidence_score) =>
    switch confidence_score
        4 => 100
        3 => 75
        2 => 50
        1 => 25
        => 25  // Default for scores below 1

// @function Create default position sizing configuration
// @param account_capital Total account capital
// @returns PositionSizeConfig with sensible defaults
export create_default_position_config(float account_capital) =>
    config = PositionSizeConfig.new()
    config.account_capital := account_capital
    config.risk_percentage := 0.01  // 1%
    config.max_position_percentage := 0.80  // 80%
    config.min_risk_per_share := 0.0  // No minimum
    config.cash_buffer_percentage := 0.10  // 10%
    config

// @function Create position sizing configuration for tight stops
// @param account_capital Total account capital
// @param max_position_percentage Maximum position percentage (lower for tight stops)
// @param min_risk_threshold Minimum risk per share to accept trade
// @returns PositionSizeConfig optimized for tight stop scenarios
export create_tight_stop_config(float account_capital, float max_position_percentage = 0.50, float min_risk_threshold = 0.05) =>
    config = PositionSizeConfig.new()
    config.account_capital := account_capital
    config.risk_percentage := 0.005  // 0.5% for tight stops
    config.max_position_percentage := max_position_percentage
    config.min_risk_per_share := min_risk_threshold
    config.cash_buffer_percentage := 0.20  // Higher buffer for tight stops
    config

// @function Calculate trade position size with confidence adjustment
// @param is_long Whether position is long
// @param entry_price Entry price
// @param confidence_score Confidence score (1-5)
// @param or_high Opening Range high
// @param or_low Opening Range low
// @param config Enhanced position sizing configuration
// @returns [shares, actual_risk, is_cap_constrained, is_risk_constrained]
export calculate_trade_position_size_enhanced(bool is_long, float entry_price, int confidence_score, float or_high, float or_low, EnhancedPositionSizeConfig config) =>
    // Calculate initial stop and risk per share
    initial_stop = calculate_initial_stop_price(is_long, or_high, or_low, config.initial_stop_buffer_percentage)
    risk_per_share = math.abs(entry_price - initial_stop)
    
    // Determine effective risk percentage
    effective_risk_pct = config.risk_percentage
    if config.use_confidence_sizing
        confidence_multiplier = calculate_position_size_confidence(confidence_score) / 100.0
        effective_risk_pct := config.risk_percentage * confidence_multiplier
    
    // Check minimum risk filter
    if config.enable_min_risk_filter and risk_per_share < config.min_risk_per_share
        [0.0, 0.0, false, true]
    else
        // Calculate position size
        target_risk_amount = config.account_capital * effective_risk_pct
        risk_based_shares = math.floor(target_risk_amount / risk_per_share)
        
        // Calculate capital constraints
        available_capital = config.account_capital * (1.0 - config.cash_buffer_percentage)
        max_position_value = available_capital * config.max_position_percentage
        capital_constrained_shares = math.floor(max_position_value / entry_price)
        
        // Use the smaller of the two
        final_shares = math.min(risk_based_shares, capital_constrained_shares)
        actual_risk = final_shares * risk_per_share
        is_cap_constrained = capital_constrained_shares < risk_based_shares
        
        [final_shares, actual_risk, is_cap_constrained, false]

// @function Handle complete trade entry logic with risk management
// @param bullish_signal Whether bullish entry signal is triggered
// @param bearish_signal Whether bearish entry signal is triggered
// @param bullish_confidence Confidence score for bullish entry (1-5)
// @param bearish_confidence Confidence score for bearish entry (1-5)
// @param trading_state Current trading state
// @param position_config Enhanced position sizing configuration
// @param show_confidence Whether to show confidence labels
// @returns [TradeExecutionResult, TradeExecutionResult] [bullish_result, bearish_result]
export handle_trade_entries_with_risk(bool bullish_signal, bool bearish_signal, int bullish_confidence, int bearish_confidence, TradingState trading_state, EnhancedPositionSizeConfig position_config, bool show_confidence) =>
    
    bullish_result = TradeExecutionResult.new()
    bearish_result = TradeExecutionResult.new()
    
    // Handle bullish entry
    if bullish_signal and trading_state.first_breakout_today and not trading_state.in_position
        // Calculate position size
        [shares_to_buy, actual_risk, is_cap_constrained, is_risk_constrained] = 
             calculate_trade_position_size_enhanced(
                 true, trading_state.current_price, bullish_confidence,
                 trading_state.or_high, trading_state.or_low, position_config
             )
        
        // Calculate initial stop
        initial_stop = calculate_initial_stop_price(true, trading_state.or_high, trading_state.or_low, position_config.initial_stop_buffer_percentage)
        
        // Only enter if position size is valid and passes risk filter
        if shares_to_buy > 0 and not is_risk_constrained
            strategy.entry("Long", strategy.long, qty=shares_to_buy)
            
            // Fill result object
            bullish_result.trade_executed := true
            bullish_result.shares := shares_to_buy
            bullish_result.actual_risk := actual_risk
            bullish_result.entry_price := trading_state.current_price
            bullish_result.initial_stop := initial_stop
            bullish_result.is_cap_constrained := is_cap_constrained
            bullish_result.is_risk_constrained := is_risk_constrained
            
            // Create enhanced label with all risk information
            if show_confidence
                risk_reward_ratio = math.abs(trading_state.current_price - initial_stop)
                label_text = "LONG ENTRY" + 
                             "\nShares: " + str.tostring(math.round(shares_to_buy, 0)) + 
                             "\nEntry: $" + str.tostring(trading_state.current_price, "#.##") +
                             "\nStop: $" + str.tostring(initial_stop, "#.##") +
                             "\nRisk: $" + str.tostring(actual_risk, "#.##") +
                             "\nR/Share: $" + str.tostring(risk_reward_ratio, "#.##") +
                             "\nConf: " + str.tostring(bullish_confidence) + "/5" +
                             (is_cap_constrained ? "\n(Cap Limited)" : "")
                
                label.new(bar_index, low * (1-position_config.label_distance), label_text, 
                         color=color.new(color.green, 70), 
                         textcolor=color.black, 
                         size=size.normal,
                         style=label.style_label_up)
        else
            // Handle risk-constrained case
            bullish_result.is_risk_constrained := is_risk_constrained
            bullish_result.entry_price := trading_state.current_price
            bullish_result.initial_stop := calculate_initial_stop_price(true, trading_state.or_high, trading_state.or_low, position_config.initial_stop_buffer_percentage)
            
            if is_risk_constrained and show_confidence
                label.new(bar_index, low * (1-position_config.label_distance), 
                         "LONG SKIPPED\nEntry: $" + str.tostring(trading_state.current_price, "#.##") +
                         "\nStop: $" + str.tostring(bullish_result.initial_stop, "#.##") +
                         "\nRisk < $" + str.tostring(position_config.min_risk_per_share, "#.##"), 
                         color=color.new(color.gray, 70), 
                         textcolor=color.black, 
                         size=size.small,
                         style=label.style_label_up)

    // Handle bearish entry
    if bearish_signal and trading_state.first_breakout_today and not trading_state.in_position
        // Calculate position size
        [shares_to_sell, actual_risk, is_cap_constrained, is_risk_constrained] = 
             calculate_trade_position_size_enhanced(
                 false, trading_state.current_price, bearish_confidence,
                 trading_state.or_high, trading_state.or_low, position_config
             )
        
        // Calculate initial stop
        initial_stop = calculate_initial_stop_price(false, trading_state.or_high, trading_state.or_low, position_config.initial_stop_buffer_percentage)
        
        // Only enter if position size is valid and passes risk filter
        if shares_to_sell > 0 and not is_risk_constrained
            strategy.entry("Short", strategy.short, qty=shares_to_sell)
            
            // Fill result object
            bearish_result.trade_executed := true
            bearish_result.shares := shares_to_sell
            bearish_result.actual_risk := actual_risk
            bearish_result.entry_price := trading_state.current_price
            bearish_result.initial_stop := initial_stop
            bearish_result.is_cap_constrained := is_cap_constrained
            bearish_result.is_risk_constrained := is_risk_constrained
            
            // Create enhanced label with all risk information
            if show_confidence
                risk_reward_ratio = math.abs(trading_state.current_price - initial_stop)
                label_text = "SHORT ENTRY" + 
                             "\nShares: " + str.tostring(math.round(shares_to_sell, 0)) + 
                             "\nEntry: $" + str.tostring(trading_state.current_price, "#.##") +
                             "\nStop: $" + str.tostring(initial_stop, "#.##") +
                             "\nRisk: $" + str.tostring(actual_risk, "#.##") +
                             "\nR/Share: $" + str.tostring(risk_reward_ratio, "#.##") +
                             "\nConf: " + str.tostring(bearish_confidence) + "/5" +
                             (is_cap_constrained ? "\n(Cap Limited)" : "")
                
                label.new(bar_index, high * (1+position_config.label_distance), label_text, 
                         color=color.new(color.red, 70), 
                         textcolor=color.black, 
                         size=size.normal,
                         style=label.style_label_down)
        else
            // Handle risk-constrained case
            bearish_result.is_risk_constrained := is_risk_constrained
            bearish_result.entry_price := trading_state.current_price
            bearish_result.initial_stop := calculate_initial_stop_price(false, trading_state.or_high, trading_state.or_low, 0.6)
            
            if is_risk_constrained and show_confidence
                label.new(bar_index, high * (1+position_config.label_distance), 
                         "SHORT SKIPPED\nEntry: $" + str.tostring(trading_state.current_price, "#.##") +
                         "\nStop: $" + str.tostring(bearish_result.initial_stop, "#.##") +
                         "\nRisk < $" + str.tostring(position_config.min_risk_per_share, "#.##"), 
                         color=color.new(color.gray, 70), 
                         textcolor=color.black, 
                         size=size.small,
                         style=label.style_label_down)
    
    [bullish_result, bearish_result]

// @function Create position data from trade execution result
// @param result Trade execution result
// @param is_long Whether position is long
// @returns PositionData object initialized from trade result
export create_position_from_trade_result(TradeExecutionResult result, bool is_long) =>
    if result.trade_executed
        pos = PositionData.new()
        pos.entry_price := result.entry_price
        pos.initial_stop := result.initial_stop
        pos.initial_risk := result.actual_risk / result.shares  // Risk per share
        pos.current_trailing_stop := result.initial_stop
        pos.highest_r_achieved := 0.0
        pos.position_is_long := is_long
        pos
    else
        PositionData.new()  // Empty position data

// Trailing Stop Usage Examples:

// Example 1: Using the original system
// config = create_standard_config()
// pos_data := update_trailing_stop(pos_data, close, config)

// Example 2a: Using your table system (fixed stops)
// config = create_table_config()
// pos_data := update_trailing_stop(pos_data, close, config)

// Example 2b: Using your table system with dynamic trailing above 5R
// config = create_table_config_with_dynamic()
// pos_data := update_trailing_stop(pos_data, close, config)

// Example 3: Dynamic step-based trailing (2R start, 0.25R steps, 0.5R trail)
// config = create_step_config(2.0, 0.25, 0.5)
// pos_data := update_trailing_stop(pos_data, close, config)

// Example 4: Custom configuration  
// levels = array.from(1.5, 2.5, 4.0, 6.0)
// stops = array.from(0.5, 1.5, 3.0, 5.0)
// config = TrailingStopConfig.new(levels, stops, 0.25, 1.5, 0.5, false)
// pos_data := update_trailing_stop(pos_data, close, config)

// Example 5: Simple dynamic trailing (starts at 3R, steps every 0.5R, trails 1R behind)
// config = create_step_config(3.0, 0.5, 1.0)  
// pos_data := update_trailing_stop(pos_data, close, config)

// Position Sizing Examples:

// Example 1: Simple calculation
// shares = calculate_position_size_simple(close, 0.50, 10000, 0.01)

// Example 2: With fixed maximum position value
// result = calculate_position_size_fixed_max(close, 0.25, 10000, 0.01, 8000)
// shares = result.shares

// Example 3: With percentage-based maximum
// result = calculate_position_size_percentage_max(close, 0.10, 10000, 0.01, 0.75)
// shares = result.shares

// Example 4: With minimum risk filter (skip trades with risk < $0.10)
// result = calculate_position_size_min_risk(close, 0.03, 10000, 0.01, 0.10)
// if result.shares > 0
//     // Take the trade
//     shares = result.shares
// else
//     // Skip trade due to minimum risk threshold

// Example 5: Advanced configuration
// config = create_default_position_config(10000)
// config.risk_percentage := 0.015  // 1.5%
// config.max_position_percentage := 0.70  // 70%
// result = calculate_position_size_advanced(close, 0.20, config)

// Example 6: Tight stop configuration
// config = create_tight_stop_config(10000, 0.40, 0.05)
// result = calculate_position_size_advanced(close, 0.02, config)
// if not result.is_risk_constrained
//     shares = result.shares

// @function Check if position should be closed due to day trading rules
// @param current_hour Current hour
// @param current_minute Current minute
// @param market_close_hour Market close hour
// @param market_close_minute Market close minute
// @returns True if position should be closed
export check_day_close(int current_hour, int current_minute, int market_close_hour, int market_close_minute) =>
    current_time = current_hour * 60 + current_minute
    market_close_time = market_close_hour * 60 + market_close_minute
    current_time >= market_close_time

// @function Check EMA 30 exit condition
// @param current_price Current price
// @param ema30 EMA 30 value
// @param position_is_long Whether position is long
// @param enable_ema30_exit Whether EMA 30 exit is enabled
// @returns True if EMA 30 exit should trigger
export check_ema30_exit(float current_price, float ema30, bool position_is_long, bool enable_ema30_exit) =>
    if enable_ema30_exit
        if position_is_long
            current_price < ema30
        else
            current_price > ema30
    else
        false

// @function Calculate R-multiple profit levels
// @param pos_data Position data
// @returns RiskLevels object with R-multiple levels
export calculate_r_levels(PositionData pos_data) =>
    levels = RiskLevels.new()
    
    if not na(pos_data.entry_price) and not na(pos_data.initial_risk)
        if pos_data.position_is_long
            levels.r2_level := pos_data.entry_price + (2 * pos_data.initial_risk)
            levels.r3_level := pos_data.entry_price + (3 * pos_data.initial_risk)
            levels.r4_level := pos_data.entry_price + (4 * pos_data.initial_risk)
        else
            levels.r2_level := pos_data.entry_price - (2 * pos_data.initial_risk)
            levels.r3_level := pos_data.entry_price - (3 * pos_data.initial_risk)
            levels.r4_level := pos_data.entry_price - (4 * pos_data.initial_risk)
    else
        levels.r2_level := na
        levels.r3_level := na
        levels.r4_level := na
    
    levels

// @function Get current R multiple for position
// @param pos_data Position data
// @param current_price Current market price
// @returns Current R multiple (can be negative)
export get_current_r_multiple(PositionData pos_data, float current_price) =>
    if na(pos_data.entry_price) or na(pos_data.initial_risk) or pos_data.initial_risk <= 0
        0.0
    else
        pos_data.position_is_long ? 
             (current_price - pos_data.entry_price) / pos_data.initial_risk :
             (pos_data.entry_price - current_price) / pos_data.initial_risk

// @function Check if trailing stop should trigger exit
// @param current_price Current market price
// @param trailing_stop Current trailing stop price
// @param position_is_long Whether position is long
// @returns True if trailing stop exit should trigger
export should_exit_trailing_stop(float current_price, float trailing_stop, bool position_is_long) =>
    if not na(trailing_stop)
        if position_is_long
            current_price <= trailing_stop
        else
            current_price >= trailing_stop
    else
        false