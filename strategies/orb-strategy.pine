//@version=6
strategy("Simple ORB Strategy", overlay=true, margin_long=100, margin_short=100, initial_capital=10000)

// Import your libraries
import kimluo2993/orb_range_lib/1 as orb_range
import kimluo2993/orb_conditions_lib/1 as orb_conditions
import kimluo2993/orb_display_lib/2 as orb_display
import kimluo2993/orb_risk_lib/5 as orb_risk

// Input parameters
or_minutes = input.int(5, "Opening Range Minutes", minval=5, maxval=120)
market_open_hour = input.int(9, "Market Open Hour", minval=0, maxval=23)
market_open_minute = input.int(30, "Market Open Minute", minval=0, maxval=59)
vol_multiplier = input.float(2.0, "Volume Multiplier", minval=1.0, maxval=5.0)
body_threshold = input.float(0.5, "Body Threshold", minval=0.1, maxval=1.0)
min_confidence = input.int(2, "Minimum Confidence Score", minval=1, maxval=5)
show_confidence = input.bool(true, "Show Confidence Labels")
enable_ema30_exit = input.bool(false, "Should Enable EMA 30 Exit")

// Position Sizing Parameters
account_capital = input.float(10000, "Account Capital", minval=1000, maxval=1000000)
risk_percentage = input.float(0.5, "Risk Per Trade (%)", minval=0.1, maxval=5.0) / 100
max_position_percentage = input.float(60.0, "Max Position Size (%)", minval=10.0, maxval=95.0) / 100
use_confidence_sizing = input.bool(false, "Use Confidence-Based Sizing")
min_risk_per_share = input.float(0.01, "Minimum Risk Per Share ($)", minval=0.01, maxval=1.0)
enable_min_risk_filter = input.bool(true, "Enable Minimum Risk Filter")

// Initialize data structures
var orb_range.ORData or_data = orb_range.ORData.new()
var orb_risk.PositionData position_data = orb_risk.PositionData.new()
var bool in_position = false

// Create trailing stop configuration
var orb_risk.TrailingStopConfig trailing_stop_config = orb_risk.create_step_config(2.0, 1, 1.0) 

// Create configuration objects
time_config = orb_range.TimeConfig.new(market_open_hour, market_open_minute, or_minutes)
vol_config = orb_conditions.VolumeConfig.new(vol_multiplier)
body_config = orb_conditions.BodyConfig.new(body_threshold, true)

// Calculate EMAs
ema20 = ta.ema(close, 20)
ema30 = ta.ema(close, 30)
ema200 = ta.ema(close, 200)
ema_data = orb_conditions.EMAData.new(ema20, ema30, ema200)

// Update OR data each bar
or_data := orb_range.update_or_data(or_data, time_config, high, low, open, close, volume)

// Get entry signals
entry_signals = orb_conditions.get_entry_signals(
     or_data.is_established, or_data.breakout_occurred, 
     high, low, open, close, volume,
     or_data.or_high, or_data.or_low, or_data.or_volume, or_data.prev_day_volume,
     ema_data, vol_config, body_config, min_confidence)

// Plot Opening Range lines
plot(or_data.is_established ? or_data.or_high : na, "OR High", color=color.red, linewidth=2)
plot(or_data.is_established ? or_data.or_low : na, "OR Low", color=color.green, linewidth=2)

// Plot EMAs
plot(ema30, "EMA 30", color=color.yellow, linewidth=1)
plot(ema200, "EMA 200", color=color.orange, linewidth=1)

// Entry logic
var bool first_breakout_today = true

// Reset first breakout flag on new day
if orb_range.detect_new_session()
    first_breakout_today := true
    in_position := false

// ===== REFACTORED ENTRY HANDLING =====
// Create enhanced position configuration once (in risk library)
var orb_risk.EnhancedPositionSizeConfig enhanced_position_config = orb_risk.create_enhanced_position_config(
     account_capital, risk_percentage, max_position_percentage, 
     use_confidence_sizing, min_risk_per_share, enable_min_risk_filter
 )

// Create trading state for current bar
trading_state = orb_risk.create_trading_state(
     first_breakout_today, in_position, close, or_data.or_high, or_data.or_low
 )

// Handle entries using the risk management library
[bullish_result, bearish_result] = orb_risk.handle_trade_entries_with_risk(
     entry_signals,
     trading_state,
     enhanced_position_config,
     show_confidence
 )

// Update position state based on execution results
if bullish_result.trade_executed
    position_data := orb_risk.create_position_from_trade_result(bullish_result, true)
    in_position := true
    first_breakout_today := false
    or_data := orb_range.mark_breakout_occurred(or_data)

if bearish_result.trade_executed
    position_data := orb_risk.create_position_from_trade_result(bearish_result, false)
    in_position := true
    first_breakout_today := false
    or_data := orb_range.mark_breakout_occurred(or_data)

// ===== END REFACTORED SECTION =====

// Update trailing stop if in position
if in_position
    position_data := orb_risk.update_trailing_stop(position_data, close, trailing_stop_config)

// Calculate R-levels for display
r_levels = orb_risk.calculate_r_levels(position_data)

// Exit conditions
day_close_exit = orb_risk.check_day_close(hour, minute, 15, 30) // Close at 3:30 PM
trailing_stop_exit = orb_risk.should_exit_trailing_stop(close, position_data.current_trailing_stop, position_data.position_is_long)

// EMA 30 exit with entry price filter
ema30_exit = false
if in_position and enable_ema30_exit
    // Only apply EMA 30 exit if entry price was above EMA 30 for longs, below EMA 30 for shorts
    if position_data.position_is_long and position_data.entry_price > ema30
        ema30_exit := orb_risk.check_ema30_exit(close, ema30, position_data.position_is_long, true)
    else if not position_data.position_is_long and position_data.entry_price < ema30
        ema30_exit := orb_risk.check_ema30_exit(close, ema30, position_data.position_is_long, true)

if in_position and (day_close_exit or trailing_stop_exit or ema30_exit)
    if strategy.position_size > 0
        strategy.close("Long")
    else if strategy.position_size < 0
        strategy.close("Short")
    in_position := false

// Plot trailing stop if in position
plot(in_position ? position_data.current_trailing_stop : na, "Trailing Stop", color=color.rgb(234, 160, 248), linewidth=2, style=plot.style_circles)

// Plot initial stop level
plot(in_position ? position_data.initial_stop : na, "Initial Stop", color=color.fuchsia, linewidth=1, style=plot.style_circles)

// Plot R-multiple profit levels
plot(in_position ? r_levels.r2_level : na, "2R Level", color=color.new(color.purple, 30), linewidth=1, style=plot.style_stepline)
plot(in_position ? r_levels.r3_level : na, "3R Level", color=color.new(color.purple, 30), linewidth=1, style=plot.style_stepline)
plot(in_position ? r_levels.r4_level : na, "4R Level", color=color.new(color.purple, 30), linewidth=1, style=plot.style_stepline)

// Background color during OR period
bgcolor(orb_range.is_in_or_period(time_config) ? color.new(color.gray, 95) : na, title="OR Period")

// Use library function for info table display
orb_display.create_simple_info_table(show_confidence, vol_multiplier, body_threshold)